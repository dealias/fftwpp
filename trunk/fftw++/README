        FFTW++: Fast Fourier Transform C++ Header Class for FFTW3 Library
  Copyright (C) 2004-12 John C. Bowman and Malcolm Roberts, University of Alberta
                    http://fftwpp.sourceforge.net

FFTW++ is a C++ header class for Version 3 of the highly optimized FFTW
(http://www.fftw.org) Fourier Transform library. It provides a simple
interface for 1D, 2D, and 3D complex-to-complex, real-to-complex, and
complex-to-real Fast Fourier Transforms and convolutions. It takes
care of the technical aspects of memory allocation, alignment, planning,
and wisdom. Wrappers for multiple 1D transforms are also provided. As with
the FFTW3 library itself, both in-place and out-of-place transforms of
arbitrary size are supported. 

Implicit dealiasing of standard and centered Hermitian convolutions is
also implemented; in 2D and 3D implicit zero-padding substantially
reduces memory usage and computation time.  For more information, see
the manuscript "Efficient Dealiased Convolutions without Padding", by
John C. Bowman and Malcolm Roberts, SIAM Journal on Scientific
Computing, 33:1, 386-406 (2011):

http://www.math.ualberta.ca/~bowman/publications/dealias.pdf

Convenient optional shift routines that place the Fourier origin in the logical
center of the domain are provided for centered complex-to-real transforms
in 2D and 3D; see fftw++.h for details.

FFTW++ supports multithreaded transforms and convolutions.
The global variable fftw::maxthreads specifies the maximum number of threads
to use. The constructors invoke a short timing test to check that using
multiple threads is actually beneficial for the given problem size.
Multithreaded routines require linking with a multithreaded FFTW implementation;
multithreading can be disabled by adding -DFFTWPP_SINGLE_THREAD to CFLAGS. 

FFTW++ can also exploit the high-performance Array class available at
http://www.math.ualberta.ca/~bowman/Array (version 1.47 or higher),
designed for scientific computing. The arrays in that package do
memory bounds checking in debugging mode, but can be optimized by
specifying the -DNDEBUG compilation option (1D arrays optimize
completely to pointer operations).

Detailed documentation is provided before each class in the fftw++.h
header file. The included examples illustrate how easy it is to use
FFTW in C++ with the FFTW++ header class. Use of the Array class is
optional, but encouraged. If for some reason the Array class is not
used, memory should be allocated with ComplexAlign (or doubleAlign) to
ensure that the data is optimally aligned to sizeof(Complex), to
enable the SIMD extensions.  The optional alignment check in fftw++.h
can be disabled with the -DNO_CHECK_ALIGN compiler option.

The following programs are provided in the examples directory:

1D examples using ComplexAlign allocator:
example0.cc
example0r.cc

1D examples using Array class:
example1.cc
example1r.cc

2D examples using Array class:
example2.cc
example2r.cc

3D examples using Array class:
example3.cc
example3r.cc

1D example of implicitly dealiased convolutions:
exampleconv.cc



Wrappers for the convolution routines are available for C, Fortran,
and Python. Examples are given in the wrappers/ directory. The C
wrapper may be found in cfftw++.h and cfftw++.cc, the Fortran wrapper
in fftwpp.f90, and the Python wrapper in fftwpp.py. A unit-testing
script, test.py, is also available. Results for the given input data
are checked with a simple hash.

The following programs are available in the wrappers directory:

Using C to call multi-threaded 1D, 2D, and 3D binary convolutions and
1D and 2D ternary convolutions, with and without passing work arrays,
where the operation in physical space may correspond to either a
scalar multiplication (M=1) or a dot product (M > 1): 
cexample.c

Using Fortran to call multi-threaded 1D, 2D, and 3D binary
convolutions, with and without passing work arrays, where the
operation in physical space may correspond to either a scalar
multiplication (mm=1) or a dot product (mm > 1):
fexample.f90

Using Python to call multi-threaded 1D, 2D, and 3D binary convolutions
(for scalar multiplication (M=1) and with work arrays created by the
constructor):
pexample.py


The following programs are provided in tests/, along with various
timing and error analysis scripts.  Asymptote
(http://asymptote.sourceforge.net/) scripts are provided for
visualizing the output.

1D complex convolution test:
cconv.cc

1D Hermitian convolution test:
conv.cc

1D Hermitian ternary convolution test:
tconv.cc

2D complex convolution test:
cconv2.cc

2D Hermitian convolution test:
conv2.cc

2D Hermitian ternary convolution test:
tconv2.cc

3D complex convolution test:
cconv3.cc

3D Hermitian convolution test:
conv3.cc

The latest developmental source code of fftw++ is available via Subversion:
svn co https://svn.code.sf.net/p/fftwpp/code/trunk/fftw++

All source files in the FFTW++ project, unless explicitly noted otherwise,
are released under version 3 (or later) of the GNU Lesser General Public
License (see the files LICENSE.LESSER and LICENSE in the top-level source
directory).

========================================================================

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

========================================================================
